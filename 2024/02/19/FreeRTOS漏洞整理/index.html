<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="近期工作项目中涉及到FreeRTOS系统，和导师一起整理FreeRTOS的相关漏洞，用于后续学习和工作。  漏洞来源：FreeRTOS Security Updates    漏洞编号 漏洞名称 漏洞类型 所属模块    &#x2F; TCP&#x2F;IP 堆栈网络缓冲区分配存在整数溢出 整数溢出 FreeRTOS-Plus-TCP   CVE-2021-43997 ARMv7-M 和 ARM">
<meta property="og:type" content="article">
<meta property="og:title" content="FreeRTOS漏洞整理">
<meta property="og:url" content="https://sx1ang.github.io/2024/02/19/FreeRTOS%E6%BC%8F%E6%B4%9E%E6%95%B4%E7%90%86/index.html">
<meta property="og:site_name" content="叶送溪&#39;s Blog.">
<meta property="og:description" content="近期工作项目中涉及到FreeRTOS系统，和导师一起整理FreeRTOS的相关漏洞，用于后续学习和工作。  漏洞来源：FreeRTOS Security Updates    漏洞编号 漏洞名称 漏洞类型 所属模块    &#x2F; TCP&#x2F;IP 堆栈网络缓冲区分配存在整数溢出 整数溢出 FreeRTOS-Plus-TCP   CVE-2021-43997 ARMv7-M 和 ARM">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://sx1ang.github.io/2024/02/19/FreeRTOS%E6%BC%8F%E6%B4%9E%E6%95%B4%E7%90%86/image-20240219181942705.png">
<meta property="article:published_time" content="2024-02-19T03:00:40.000Z">
<meta property="article:modified_time" content="2024-02-20T09:34:10.976Z">
<meta property="article:author" content="叶送溪">
<meta property="article:tag" content="漏洞整理">
<meta property="article:tag" content="RTOS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://sx1ang.github.io/2024/02/19/FreeRTOS%E6%BC%8F%E6%B4%9E%E6%95%B4%E7%90%86/image-20240219181942705.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>FreeRTOS漏洞整理</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
      <link rel="alternate" href="/true" title="叶送溪&#39;s Blog." type="application/atom+xml" />
    
	<!-- mathjax -->
	
		<script type="text/x-mathjax-config">
		  MathJax.Hub.Config({
			tex2jax: {
			  skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
			  inlineMath: [['$','$']]
			}
		  });
		</script>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
	
<meta name="generator" content="Hexo 6.3.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/archives/">Archives</a></li><!--
     --><!--
       --><li><a href="/categories/">Categories</a></li><!--
     --><!--
       --><li><a href="/tags/">Tags</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/note/">Note</a></li><!--
     --><!--
       --><li><a href="/link/">Links</a></li><!--
     --><!--
       --><li><a href="/search/">Search</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post" href="/2024/02/21/DDS%E6%BC%8F%E6%B4%9E%E6%95%B4%E7%90%86/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Next post" href="/2024/01/31/%E6%9F%90%E4%B9%A6%E4%BC%9A%E8%AE%AE%E5%AE%A4%E9%A2%84%E5%AE%9A%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90-protobuf/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://sx1ang.github.io/2024/02/19/FreeRTOS%E6%BC%8F%E6%B4%9E%E6%95%B4%E7%90%86/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://sx1ang.github.io/2024/02/19/FreeRTOS%E6%BC%8F%E6%B4%9E%E6%95%B4%E7%90%86/&text=FreeRTOS漏洞整理"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://sx1ang.github.io/2024/02/19/FreeRTOS%E6%BC%8F%E6%B4%9E%E6%95%B4%E7%90%86/&title=FreeRTOS漏洞整理"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://sx1ang.github.io/2024/02/19/FreeRTOS%E6%BC%8F%E6%B4%9E%E6%95%B4%E7%90%86/&is_video=false&description=FreeRTOS漏洞整理"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=FreeRTOS漏洞整理&body=Check out this article: https://sx1ang.github.io/2024/02/19/FreeRTOS%E6%BC%8F%E6%B4%9E%E6%95%B4%E7%90%86/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://sx1ang.github.io/2024/02/19/FreeRTOS%E6%BC%8F%E6%B4%9E%E6%95%B4%E7%90%86/&title=FreeRTOS漏洞整理"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://sx1ang.github.io/2024/02/19/FreeRTOS%E6%BC%8F%E6%B4%9E%E6%95%B4%E7%90%86/&title=FreeRTOS漏洞整理"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://sx1ang.github.io/2024/02/19/FreeRTOS%E6%BC%8F%E6%B4%9E%E6%95%B4%E7%90%86/&title=FreeRTOS漏洞整理"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://sx1ang.github.io/2024/02/19/FreeRTOS%E6%BC%8F%E6%B4%9E%E6%95%B4%E7%90%86/&title=FreeRTOS漏洞整理"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://sx1ang.github.io/2024/02/19/FreeRTOS%E6%BC%8F%E6%B4%9E%E6%95%B4%E7%90%86/&name=FreeRTOS漏洞整理&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://sx1ang.github.io/2024/02/19/FreeRTOS%E6%BC%8F%E6%B4%9E%E6%95%B4%E7%90%86/&t=FreeRTOS漏洞整理"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-IP-%E5%A0%86%E6%A0%88%E7%BD%91%E7%BB%9C%E7%BC%93%E5%86%B2%E5%8C%BA%E5%88%86%E9%85%8D%E5%AD%98%E5%9C%A8%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA"><span class="toc-number">1.</span> <span class="toc-text">TCP&#x2F;IP 堆栈网络缓冲区分配存在整数溢出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E6%8F%8F%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">漏洞描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E8%AF%A6%E6%83%85"><span class="toc-number">1.2.</span> <span class="toc-text">漏洞详情</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88"><span class="toc-number">1.3.</span> <span class="toc-text">修复方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ARMv7-M-%E5%92%8C-ARMv8-M-MPU-%E7%9A%84%E7%A7%BB%E6%A4%8D%E7%89%88%E6%9C%AC%E5%AD%98%E5%9C%A8%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87"><span class="toc-number">2.</span> <span class="toc-text">ARMv7-M 和 ARMv8-M MPU 的移植版本存在权限提升</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E6%8F%8F%E8%BF%B0-1"><span class="toc-number">2.1.</span> <span class="toc-text">漏洞描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E8%AF%A6%E6%83%85-1"><span class="toc-number">2.2.</span> <span class="toc-text">漏洞详情</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88-1"><span class="toc-number">2.3.</span> <span class="toc-text">修复方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E4%B8%AD%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%AD%98%E5%9C%A8%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA"><span class="toc-number">3.</span> <span class="toc-text">堆中动态内存分配存在整数溢出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E6%8F%8F%E8%BF%B0-2"><span class="toc-number">3.1.</span> <span class="toc-text">漏洞描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E8%AF%A6%E6%83%85-2"><span class="toc-number">3.2.</span> <span class="toc-text">漏洞详情</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88-2"><span class="toc-number">3.3.</span> <span class="toc-text">修复方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%AD%98%E5%9C%A8%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA"><span class="toc-number">4.</span> <span class="toc-text">队列创建过程中内存分配存在整数溢出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E6%8F%8F%E8%BF%B0-3"><span class="toc-number">4.1.</span> <span class="toc-text">漏洞描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E8%AF%A6%E6%83%85-3"><span class="toc-number">4.2.</span> <span class="toc-text">漏洞详情</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88-3"><span class="toc-number">4.3.</span> <span class="toc-text">修复方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E7%BC%93%E5%86%B2%E5%8C%BA%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%AD%98%E5%9C%A8%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA"><span class="toc-number">5.</span> <span class="toc-text">流缓冲区创建过程中内存分配存在整数溢出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E6%8F%8F%E8%BF%B0-4"><span class="toc-number">5.1.</span> <span class="toc-text">漏洞描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E8%AF%A6%E6%83%85-4"><span class="toc-number">5.2.</span> <span class="toc-text">漏洞详情</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88-4"><span class="toc-number">5.3.</span> <span class="toc-text">修复方案</span></a></li></ol></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        FreeRTOS漏洞整理
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">叶送溪</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2024-02-19T03:00:40.000Z" class="dt-published" itemprop="datePublished">2024-02-19</time>
        
        (Updated: <time datetime="2024-02-20T09:34:10.976Z" class="dt-updated" itemprop="dateModified">2024-02-20</time>)
        
      
    </div>


      
    <div class="article-category">
        <i class="fa-solid fa-archive"></i>
        <a class="category-link" href="/categories/%E6%BC%8F%E6%B4%9E%E6%95%B4%E7%90%86/">漏洞整理</a>
    </div>


      
    <div class="article-tag">
        <i class="fa-solid fa-tag"></i>
        <a class="p-category" href="/tags/RTOS/" rel="tag">RTOS</a>, <a class="p-category" href="/tags/%E6%BC%8F%E6%B4%9E%E6%95%B4%E7%90%86/" rel="tag">漏洞整理</a>
    </div>


    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <blockquote>
<p>近期工作项目中涉及到FreeRTOS系统，和导师一起整理FreeRTOS的相关漏洞，用于后续学习和工作。</p>
</blockquote>
<p><strong>漏洞来源：<a target="_blank" rel="noopener" href="https://www.freertos.org/security/security_updates.html">FreeRTOS Security Updates</a></strong></p>
<table>
<thead>
<tr>
<th align="center">漏洞编号</th>
<th align="left">漏洞名称</th>
<th align="center">漏洞类型</th>
<th align="left">所属模块</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&#x2F;</td>
<td align="left">TCP&#x2F;IP 堆栈网络缓冲区分配存在整数溢出</td>
<td align="center">整数溢出</td>
<td align="left">FreeRTOS-Plus-TCP</td>
</tr>
<tr>
<td align="center"><a target="_blank" rel="noopener" href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-43997">CVE-2021-43997</a></td>
<td align="left">ARMv7-M 和 ARMv8-M MPU 的移植版本存在权限提升</td>
<td align="center">权限提升</td>
<td align="left">FreeRTOS Kernel</td>
</tr>
<tr>
<td align="center"><a target="_blank" rel="noopener" href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-32020">CVE-2021-32020</a></td>
<td align="left">堆中动态内存分配存在整数溢出</td>
<td align="center">整数溢出</td>
<td align="left">FreeRTOS Kernel</td>
</tr>
<tr>
<td align="center"><a target="_blank" rel="noopener" href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-31571">CVE-2021-31571</a></td>
<td align="left">队列创建过程中内存分配存在整数溢出</td>
<td align="center">整数溢出</td>
<td align="left">FreeRTOS Kernel</td>
</tr>
<tr>
<td align="center"><a target="_blank" rel="noopener" href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-31572">CVE-2021-31572</a></td>
<td align="left">流缓冲区创建过程中内存分配存在整数溢出</td>
<td align="center">整数溢出</td>
<td align="left">FreeRTOS Kernel</td>
</tr>
</tbody></table>
<h2 id="TCP-IP-堆栈网络缓冲区分配存在整数溢出"><a href="#TCP-IP-堆栈网络缓冲区分配存在整数溢出" class="headerlink" title="TCP&#x2F;IP 堆栈网络缓冲区分配存在整数溢出"></a>TCP&#x2F;IP 堆栈网络缓冲区分配存在整数溢出</h2><h3 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h3><p><strong>09&#x2F;10&#x2F;2021 - FreeRTOS-Plus-TCP V2.3.3 and earlier</strong></p>
<ul>
<li>In <a target="_blank" rel="noopener" href="https://github.com/FreeRTOS/FreeRTOS-Plus-TCP/blob/main/source/portable/BufferManagement/BufferAllocation_2.c">BufferAllocation_2.c</a>, there is an unchecked possible addition overflow when calculating the size of the block of memory to be allocated for a network buffer that could result in the size overflowing and the allocation returning success but allocating only a fraction of the memory asked for. With default settings, this would only occur when attempting to allocate within 12 bytes of 4 GB.</li>
</ul>
<p>在FreeRTOS-Plus-TCP TCP&#x2F;IP 堆栈网络缓冲区分配方案<a target="_blank" rel="noopener" href="https://github.com/FreeRTOS/FreeRTOS-Plus-TCP/blob/main/source/portable/BufferManagement/BufferAllocation_2.c">BufferAllocation_2.c</a>中，计算要分配给网络缓冲区的内存块的大小时， 未对加法操作进行检查，导致出现整数上溢（整数下溢一般出现在减法操作中），分配的网络缓冲区大小远小于请求分配的大小，后续将进一步造成缓冲区溢出。</p>
<h3 id="漏洞详情"><a href="#漏洞详情" class="headerlink" title="漏洞详情"></a>漏洞详情</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint8_t</span> * <span class="title function_">pucGetNetworkBuffer</span><span class="params">( <span class="type">size_t</span> * pxRequestedSizeBytes )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> * pucEthernetBuffer;</span><br><span class="line">    <span class="type">size_t</span> xSize = *pxRequestedSizeBytes;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xSize要大于最小值</span></span><br><span class="line">    <span class="keyword">if</span>( xSize &lt; baMINIMAL_BUFFER_SIZE )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Buffers must be at least large enough to hold a TCP-packet with</span></span><br><span class="line"><span class="comment">         * headers, or an ARP packet, in case TCP is not included. */</span></span><br><span class="line">        xSize = baMINIMAL_BUFFER_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Round up xSize to the nearest multiple of N bytes,</span></span><br><span class="line"><span class="comment">     * where N equals &#x27;sizeof( size_t )&#x27;. */</span></span><br><span class="line">    <span class="comment">// 检查是否对齐</span></span><br><span class="line">    <span class="keyword">if</span>( ( xSize &amp; ( <span class="keyword">sizeof</span>( <span class="type">size_t</span> ) - <span class="number">1U</span> ) ) != <span class="number">0U</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 对齐过程存在整数上溢</span></span><br><span class="line">        xSize = ( xSize | ( <span class="keyword">sizeof</span>( <span class="type">size_t</span> ) - <span class="number">1U</span> ) ) + <span class="number">1U</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *pxRequestedSizeBytes = xSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocate a buffer large enough to store the requested Ethernet frame size</span></span><br><span class="line"><span class="comment">     * and a pointer to a network buffer structure (hence the addition of</span></span><br><span class="line"><span class="comment">     * ipBUFFER_PADDING bytes). */</span></span><br><span class="line">    pucEthernetBuffer = ( <span class="type">uint8_t</span> * ) pvPortMalloc( xSize + ipBUFFER_PADDING );</span><br><span class="line">    configASSERT( pucEthernetBuffer != <span class="literal">NULL</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( pucEthernetBuffer != <span class="literal">NULL</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Enough space is left at the start of the buffer to place a pointer to</span></span><br><span class="line"><span class="comment">         * the network buffer structure that references this Ethernet buffer.</span></span><br><span class="line"><span class="comment">         * Return a pointer to the start of the Ethernet buffer itself. */</span></span><br><span class="line">        pucEthernetBuffer += ipBUFFER_PADDING;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pucEthernetBuffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在pucGetNetworkBuffer()函数中，首先会检查xSize是否对齐：( xSize &amp; ( sizeof( size_t ) - 1U ) ) !&#x3D; 0U，如果没有对齐，则执行对齐操作：xSize &#x3D; ( xSize | ( sizeof( size_t ) - 1U ) ) + 1U。问题就出在进行对齐的代码中，如果xSize的值和size_t所能表示的最大值非常接近，进行对齐之后xSize就等于size_t所能表示的最大值，然后再+1，就会造成整数上溢，导致最后xSize的值为0，远小于请求的内存大小，这里需要对xSize的值进行检查。例如：sizeof( size_t )&#x3D;8，size_t所能表示的最大值为255，如果请求分配的内存大小为250，xSize | ( sizeof( size_t ) - 1U对齐之后大小为255，再+1结果为0。</p>
<p>最后pvPortMalloc( xSize + ipBUFFER_PADDING )函数申请到的内存块小于请求的* pxRequestedSizeBytes，会导致后续使用缓冲区pucEthernetBuffer时产生缓冲区溢出。其中xSize + ipBUFFER_PADDING也可能存在整数溢出。</p>
<p>在pxGetNetworkBufferWithDescriptor()函数和pxResizeNetworkBufferWithDescriptor()函数中同样存在此漏洞。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">NetworkBufferDescriptor_t * <span class="title function_">pxGetNetworkBufferWithDescriptor</span><span class="params">( <span class="type">size_t</span> xRequestedSizeBytes,</span></span><br><span class="line"><span class="params">                                                              TickType_t xBlockTimeTicks )</span></span><br><span class="line">&#123;</span><br><span class="line">    NetworkBufferDescriptor_t * pxReturn = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">size_t</span> uxCount;</span><br><span class="line"></span><br><span class="line">    ···</span><br><span class="line">            <span class="keyword">if</span>( xRequestedSizeBytes &gt; <span class="number">0U</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>( ( xRequestedSizeBytes &lt; ( <span class="type">size_t</span> ) baMINIMAL_BUFFER_SIZE ) )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">/* ARP packets can replace application packets, so the storage must be</span></span><br><span class="line"><span class="comment">                     * at least large enough to hold an ARP. */</span></span><br><span class="line">                    xRequestedSizeBytes = baMINIMAL_BUFFER_SIZE;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* Add 2 bytes to xRequestedSizeBytes and round up xRequestedSizeBytes</span></span><br><span class="line"><span class="comment">                 * to the nearest multiple of N bytes, where N equals &#x27;sizeof( size_t )&#x27;. */</span></span><br><span class="line">                xRequestedSizeBytes += <span class="number">2U</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>( ( xRequestedSizeBytes &amp; ( <span class="keyword">sizeof</span>( <span class="type">size_t</span> ) - <span class="number">1U</span> ) ) != <span class="number">0U</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 对齐过程存在整数上溢</span></span><br><span class="line">                    xRequestedSizeBytes = ( xRequestedSizeBytes | ( <span class="keyword">sizeof</span>( <span class="type">size_t</span> ) - <span class="number">1U</span> ) ) + <span class="number">1U</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* Extra space is obtained so a pointer to the network buffer can</span></span><br><span class="line"><span class="comment">                 * be stored at the beginning of the buffer. */</span></span><br><span class="line">                pxReturn-&gt;pucEthernetBuffer = ( <span class="type">uint8_t</span> * ) pvPortMalloc( xRequestedSizeBytes + ipBUFFER_PADDING );</span><br><span class="line">                ···</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">NetworkBufferDescriptor_t * <span class="title function_">pxResizeNetworkBufferWithDescriptor</span><span class="params">( NetworkBufferDescriptor_t * pxNetworkBuffer,</span></span><br><span class="line"><span class="params">                                                                 <span class="type">size_t</span> xNewSizeBytes )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> xOriginalLength;</span><br><span class="line">    <span class="type">uint8_t</span> * pucBuffer;</span><br><span class="line"></span><br><span class="line">    xOriginalLength = pxNetworkBuffer-&gt;xDataLength + ipBUFFER_PADDING;</span><br><span class="line">    xNewSizeBytes = xNewSizeBytes + ipBUFFER_PADDING;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 调用pucGetNetworkBuffer()</span></span><br><span class="line">    pucBuffer = pucGetNetworkBuffer( &amp;( xNewSizeBytes ) );</span><br><span class="line">    ···</span><br></pre></td></tr></table></figure>

<h3 id="修复方案"><a href="#修复方案" class="headerlink" title="修复方案"></a>修复方案</h3><p><a target="_blank" rel="noopener" href="https://github.com/FreeRTOS/FreeRTOS-Plus-TCP/compare/V2.3.4...main?diff=split&w=#diff-5f070408ed1e32bbb621dc0fd89c3dcc84fa75e279eb5165539d413d6cd12d87R236">https://github.com/FreeRTOS/FreeRTOS-Plus-TCP/compare/V2.3.4...main?diff=split&amp;w=#diff-5f070408ed1e32bbb621dc0fd89c3dcc84fa75e279eb5165539d413d6cd12d87R236</a></p>
<p><img src="/2024/02/19/FreeRTOS%E6%BC%8F%E6%B4%9E%E6%95%B4%E7%90%86/image-20240219181942705.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> baALIGNMENT_BYTES            ( sizeof( size_t ) )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> baALIGNMENT_MASK             ( baALIGNMENT_BYTES - 1U )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> baADD_WILL_OVERFLOW( a, b )    ( ( a ) &gt; ( SIZE_MAX - ( b ) ) )</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> * <span class="title function_">pucGetNetworkBuffer</span><span class="params">( <span class="type">size_t</span> * pxRequestedSizeBytes )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> * pucEthernetBuffer = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">size_t</span> uxMaxAllowedBytes = ( SIZE_MAX &gt;&gt; <span class="number">1</span> );</span><br><span class="line">    <span class="type">size_t</span> xSize = *pxRequestedSizeBytes;</span><br><span class="line">    <span class="type">size_t</span> xBytesRequiredForAlignment, xAllocatedBytes;</span><br><span class="line">    BaseType_t xIntegerOverflowed = pdFALSE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( xSize &lt; baMINIMAL_BUFFER_SIZE )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Buffers must be at least large enough to hold a TCP-packet with</span></span><br><span class="line"><span class="comment">         * headers, or an ARP packet, in case TCP is not included. */</span></span><br><span class="line">        xSize = baMINIMAL_BUFFER_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Round up xSize to the nearest multiple of N bytes,</span></span><br><span class="line"><span class="comment">     * where N equals &#x27;sizeof( size_t )&#x27;. */</span></span><br><span class="line">    <span class="keyword">if</span>( ( xSize &amp; baALIGNMENT_MASK ) != <span class="number">0U</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// xBytesRequiredForAlignment表示对齐需要补齐的字节数</span></span><br><span class="line">        xBytesRequiredForAlignment = baALIGNMENT_BYTES - ( xSize &amp; baALIGNMENT_MASK );</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// baADD_WILL_OVERFLOW检查对齐之后是否会溢出</span></span><br><span class="line">        <span class="keyword">if</span>( baADD_WILL_OVERFLOW( xSize, xBytesRequiredForAlignment ) == pdFAIL )</span><br><span class="line">        &#123;</span><br><span class="line">            xSize += xBytesRequiredForAlignment;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            xIntegerOverflowed = pdTRUE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// baADD_WILL_OVERFLOW检查添加padding之后是否会溢出</span></span><br><span class="line">    <span class="keyword">if</span>( baADD_WILL_OVERFLOW( xSize, ipBUFFER_PADDING ) == pdFAIL )</span><br><span class="line">    &#123;</span><br><span class="line">        xAllocatedBytes = xSize + ipBUFFER_PADDING;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        xIntegerOverflowed = pdTRUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 未产生溢出才分配内存</span></span><br><span class="line">    <span class="keyword">if</span>( ( xIntegerOverflowed == pdFALSE ) &amp;&amp; ( xAllocatedBytes &lt;= uxMaxAllowedBytes ) )</span><br><span class="line">    &#123;</span><br><span class="line">        *pxRequestedSizeBytes = xSize;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Allocate a buffer large enough to store the requested Ethernet frame size</span></span><br><span class="line"><span class="comment">         * and a pointer to a network buffer structure (hence the addition of</span></span><br><span class="line"><span class="comment">         * ipBUFFER_PADDING bytes). */</span></span><br><span class="line">        pucEthernetBuffer = ( <span class="type">uint8_t</span> * ) pvPortMalloc( xAllocatedBytes );</span><br><span class="line">        configASSERT( pucEthernetBuffer != <span class="literal">NULL</span> );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( pucEthernetBuffer != <span class="literal">NULL</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* Enough space is left at the start of the buffer to place a pointer to</span></span><br><span class="line"><span class="comment">             * the network buffer structure that references this Ethernet buffer.</span></span><br><span class="line"><span class="comment">             * Return a pointer to the start of the Ethernet buffer itself. */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* MISRA Ref 18.4.1 [Usage of +, -, += and -= operators on expression of pointer type]. */</span></span><br><span class="line">            <span class="comment">/* More details at: https://github.com/FreeRTOS/FreeRTOS-Plus-TCP/blob/main/MISRA.md#rule-184. */</span></span><br><span class="line">            <span class="comment">/* coverity[misra_c_2012_rule_18_4_violation] */</span></span><br><span class="line">            pucEthernetBuffer += ipBUFFER_PADDING;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pucEthernetBuffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="ARMv7-M-和-ARMv8-M-MPU-的移植版本存在权限提升"><a href="#ARMv7-M-和-ARMv8-M-MPU-的移植版本存在权限提升" class="headerlink" title="ARMv7-M 和 ARMv8-M MPU 的移植版本存在权限提升"></a>ARMv7-M 和 ARMv8-M MPU 的移植版本存在权限提升</h2><h3 id="漏洞描述-1"><a href="#漏洞描述-1" class="headerlink" title="漏洞描述"></a>漏洞描述</h3><p><strong>11&#x2F;12&#x2F;2021 - FreeRTOS Kernel versions 10.2.0 to 10.4.5 (inclusive)</strong></p>
<ul>
<li>ARMv7-M and ARMv8-M MPU ports: It is possible for an unprivileged task to raise its privilege by calling the internal function <code>xPortRaisePrivilege</code>.</li>
</ul>
<p>The public CVE record for this can be found at MITRE: <a target="_blank" rel="noopener" href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-43997">CVE-2021-43997</a>.</p>
<p>在针对 ARMv7-M 和 ARMv8-M MPU 的移植版本中，非特权任务可以通过调用内部函数xPortRaisePrivilege()提升其特权。</p>
<h3 id="漏洞详情-1"><a href="#漏洞详情-1" class="headerlink" title="漏洞详情"></a>漏洞详情</h3><p><em><strong>&#x2F;portable&#x2F;Common&#x2F;mpu_wrappers.c</strong></em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Calls the port specific code to raise the privilege.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return pdFALSE if privilege was raised, pdTRUE otherwise.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xPortRaisePrivilege</span><span class="params">( <span class="type">void</span> )</span> FREERTOS_SYSTEM_CALL;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief If xRunningPrivileged is not pdTRUE, calls the port specific</span></span><br><span class="line"><span class="comment"> * code to reset the privilege, otherwise does nothing.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vPortResetPrivilege</span><span class="params">( BaseType_t xRunningPrivileged )</span>;</span><br><span class="line"><span class="comment">/*-----------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line">BaseType_t <span class="title function_">xPortRaisePrivilege</span><span class="params">( <span class="type">void</span> )</span> <span class="comment">/* FREERTOS_SYSTEM_CALL */</span></span><br><span class="line">&#123;</span><br><span class="line">    BaseType_t xRunningPrivileged;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check whether the processor is already privileged. */</span></span><br><span class="line">    xRunningPrivileged = portIS_PRIVILEGED();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the processor is not already privileged, raise privilege. */</span></span><br><span class="line">    <span class="keyword">if</span>( xRunningPrivileged == pdFALSE )</span><br><span class="line">    &#123;</span><br><span class="line">        portRAISE_PRIVILEGE();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> xRunningPrivileged;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*-----------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vPortResetPrivilege</span><span class="params">( BaseType_t xRunningPrivileged )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( xRunningPrivileged == pdFALSE )</span><br><span class="line">    &#123;</span><br><span class="line">        portRESET_PRIVILEGE();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在mpu_wrappers.c中，xPortRaisePrivilege()和vPortResetPrivilege()都被定义为函数，可以链接到xPortRaisePrivilege()和vPortResetPrivilege()函数标识符的代码都可以调用它们，这意味着非内核代码（如果不恰当地实现）有可能调用xPortRaisePrivilege()和vPortResetPrivilege()函数提升权限。</p>
<h3 id="修复方案-1"><a href="#修复方案-1" class="headerlink" title="修复方案"></a>修复方案</h3><p><a target="_blank" rel="noopener" href="https://github.com/FreeRTOS/FreeRTOS-Kernel/commit/7a3848753b303cffe658abc11110d008669f7021">https://github.com/FreeRTOS/FreeRTOS-Kernel/commit/7a3848753b303cffe658abc11110d008669f7021</a></p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">diff --git a/include/mpu_wrappers.h b/include/mpu_wrappers.h</span></span><br><span class="line"><span class="comment">index 7f07d0001e..c44184d729 100644</span></span><br><span class="line"><span class="comment">--- a/include/mpu_wrappers.h</span></span><br><span class="line"><span class="comment">+++ b/include/mpu_wrappers.h</span></span><br><span class="line"><span class="meta">@@ -168,11 +168,41 @@</span></span><br><span class="line"> </span><br><span class="line">     #else /* MPU_WRAPPERS_INCLUDED_FROM_API_FILE */</span><br><span class="line"> </span><br><span class="line"><span class="deletion">-/* Ensure API functions go in the privileged execution section. */</span></span><br><span class="line"><span class="addition">+        /* Ensure API functions go in the privileged execution section. */</span></span><br><span class="line">         #define PRIVILEGED_FUNCTION     __attribute__( ( section( &quot;privileged_functions&quot; ) ) )</span><br><span class="line">         #define PRIVILEGED_DATA         __attribute__( ( section( &quot;privileged_data&quot; ) ) )</span><br><span class="line">         #define FREERTOS_SYSTEM_CALL    __attribute__( ( section( &quot;freertos_system_calls&quot; ) ) )</span><br><span class="line"> </span><br><span class="line"><span class="addition">+        /**</span></span><br><span class="line"><span class="addition">+         * @brief Calls the port specific code to raise the privilege.</span></span><br><span class="line"><span class="addition">+         *</span></span><br><span class="line"><span class="addition">+         * Sets xRunningPrivileged to pdFALSE if privilege was raised, else sets</span></span><br><span class="line"><span class="addition">+         * it to pdTRUE.</span></span><br><span class="line"><span class="addition">+         */</span></span><br><span class="line"><span class="addition">+        #define xPortRaisePrivilege( xRunningPrivileged )                      \</span></span><br><span class="line"><span class="addition">+        &#123;                                                                      \</span></span><br><span class="line"><span class="addition">+            /* Check whether the processor is already privileged. */           \</span></span><br><span class="line"><span class="addition">+            xRunningPrivileged = portIS_PRIVILEGED();                          \</span></span><br><span class="line"><span class="addition">+                                                                               \</span></span><br><span class="line"><span class="addition">+            /* If the processor is not already privileged, raise privilege. */ \</span></span><br><span class="line"><span class="addition">+            if( xRunningPrivileged == pdFALSE )                                \</span></span><br><span class="line"><span class="addition">+            &#123;                                                                  \</span></span><br><span class="line"><span class="addition">+                portRAISE_PRIVILEGE();                                         \</span></span><br><span class="line"><span class="addition">+            &#125;                                                                  \</span></span><br><span class="line"><span class="addition">+        &#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+        /**</span></span><br><span class="line"><span class="addition">+         * @brief If xRunningPrivileged is not pdTRUE, calls the port specific</span></span><br><span class="line"><span class="addition">+         * code to reset the privilege, otherwise does nothing.</span></span><br><span class="line"><span class="addition">+         */</span></span><br><span class="line"><span class="addition">+        #define vPortResetPrivilege( xRunningPrivileged )   \</span></span><br><span class="line"><span class="addition">+        &#123;                                                   \</span></span><br><span class="line"><span class="addition">+            if( xRunningPrivileged == pdFALSE )             \</span></span><br><span class="line"><span class="addition">+            &#123;                                               \</span></span><br><span class="line"><span class="addition">+                portRESET_PRIVILEGE();                      \</span></span><br><span class="line"><span class="addition">+            &#125;                                               \</span></span><br><span class="line"><span class="addition">+        &#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line">     #endif /* MPU_WRAPPERS_INCLUDED_FROM_API_FILE */</span><br><span class="line"> </span><br><span class="line"> #else /* portUSING_MPU_WRAPPERS */</span><br><span class="line"><span class="comment">diff --git a/portable/Common/mpu_wrappers.c b/portable/Common/mpu_wrappers.c</span></span><br><span class="line"><span class="comment">index 7a04fb8a7d..c5b71d14b8 100644</span></span><br><span class="line"><span class="comment">--- a/portable/Common/mpu_wrappers.c</span></span><br><span class="line"><span class="comment">+++ b/portable/Common/mpu_wrappers.c</span></span><br><span class="line"><span class="meta">@@ -46,45 +46,6 @@</span></span><br><span class="line"> #include &quot;mpu_prototypes.h&quot;</span><br><span class="line"> </span><br><span class="line"> #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE</span><br><span class="line"><span class="deletion">-</span></span><br><span class="line"><span class="deletion">-/**</span></span><br><span class="line"><span class="deletion">- * @brief Calls the port specific code to raise the privilege.</span></span><br><span class="line"><span class="deletion">- *</span></span><br><span class="line"><span class="deletion">- * @return pdFALSE if privilege was raised, pdTRUE otherwise.</span></span><br><span class="line"><span class="deletion">- */</span></span><br><span class="line"><span class="deletion">-BaseType_t xPortRaisePrivilege( void ) FREERTOS_SYSTEM_CALL;</span></span><br><span class="line"><span class="deletion">-</span></span><br><span class="line"><span class="deletion">-/**</span></span><br><span class="line"><span class="deletion">- * @brief If xRunningPrivileged is not pdTRUE, calls the port specific</span></span><br><span class="line"><span class="deletion">- * code to reset the privilege, otherwise does nothing.</span></span><br><span class="line"><span class="deletion">- */</span></span><br><span class="line"><span class="deletion">-void vPortResetPrivilege( BaseType_t xRunningPrivileged );</span></span><br><span class="line"><span class="deletion">-/*-----------------------------------------------------------*/</span></span><br><span class="line"><span class="deletion">-</span></span><br><span class="line"><span class="deletion">-BaseType_t xPortRaisePrivilege( void ) /* FREERTOS_SYSTEM_CALL */</span></span><br><span class="line"><span class="deletion">-&#123;</span></span><br><span class="line"><span class="deletion">-    BaseType_t xRunningPrivileged;</span></span><br><span class="line"><span class="deletion">-</span></span><br><span class="line"><span class="deletion">-    /* Check whether the processor is already privileged. */</span></span><br><span class="line"><span class="deletion">-    xRunningPrivileged = portIS_PRIVILEGED();</span></span><br><span class="line"><span class="deletion">-</span></span><br><span class="line"><span class="deletion">-    /* If the processor is not already privileged, raise privilege. */</span></span><br><span class="line"><span class="deletion">-    if( xRunningPrivileged == pdFALSE )</span></span><br><span class="line"><span class="deletion">-    &#123;</span></span><br><span class="line"><span class="deletion">-        portRAISE_PRIVILEGE();</span></span><br><span class="line"><span class="deletion">-    &#125;</span></span><br><span class="line"><span class="deletion">-</span></span><br><span class="line"><span class="deletion">-    return xRunningPrivileged;</span></span><br><span class="line"><span class="deletion">-&#125;</span></span><br><span class="line"><span class="deletion">-/*-----------------------------------------------------------*/</span></span><br><span class="line"><span class="deletion">-</span></span><br><span class="line"><span class="deletion">-void vPortResetPrivilege( BaseType_t xRunningPrivileged )</span></span><br><span class="line"><span class="deletion">-&#123;</span></span><br><span class="line"><span class="deletion">-    if( xRunningPrivileged == pdFALSE )</span></span><br><span class="line"><span class="deletion">-    &#123;</span></span><br><span class="line"><span class="deletion">-        portRESET_PRIVILEGE();</span></span><br><span class="line"><span class="deletion">-    &#125;</span></span><br><span class="line"><span class="deletion">-&#125;</span></span><br></pre></td></tr></table></figure>

<p>修复方法是将xPortRaisePrivilege()和vPortResetPrivilege()函数重新定义为宏，放在mpu_wrappers.h中，将函数转换为宏可以在一定程度上减小风险：</p>
<ul>
<li>宏在预处理阶段直接展开到调用宏的代码中，宏没有一个在链接阶段可解析和可调用的函数地址，因此难以被非预期的代码直接调用；</li>
<li>宏可以在编译时控制可见性，比如通过在宏的定义前使用 <code>static</code> 或其他编译器特定的指示，确保这些宏只能在预定义的文件或模块中使用；</li>
<li>宏还可以增加额外的安全检查或条件编译逻辑，以便仅在确定是内核代码时才允许权限升级。</li>
</ul>
<h2 id="堆中动态内存分配存在整数溢出"><a href="#堆中动态内存分配存在整数溢出" class="headerlink" title="堆中动态内存分配存在整数溢出"></a>堆中动态内存分配存在整数溢出</h2><h3 id="漏洞描述-2"><a href="#漏洞描述-2" class="headerlink" title="漏洞描述"></a>漏洞描述</h3><p><strong>12&#x2F;15&#x2F;2020 - FreeRTOS Kernel V10.4.2 and earlier</strong></p>
<ul>
<li>In <a target="_blank" rel="noopener" href="https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/0b0a2060c0f40a561f97ad7bfbf35d983c33a686/portable/MemMang/heap_2.c#L139">heap2.c</a> there is an unchecked possible addition overflow when calculating the size of the block of memory to be allocated that could result in the size overflowing and the allocation returning success but allocating only a fraction of the memory asked for. This will only affect code where the amount of memory being allocated is within 8 bytes of 4 GB.</li>
</ul>
<p>FreeRTOS V10.4.3 and newer contains additional code that checks for and prevents these potential overflows.</p>
<p>The public CVE record for this can be found at MITRE: <a target="_blank" rel="noopener" href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-32020">CVE-2021-32020</a>.</p>
<p>在heap2.c中，计算要分配的内存块的大小时， 未对加法操作进行检查，导致出现整数上溢，分配的内存块大小远小于请求分配的大小，后续将进一步造成缓冲区溢出。</p>
<h3 id="漏洞详情-2"><a href="#漏洞详情-2" class="headerlink" title="漏洞详情"></a>漏洞详情</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> * <span class="title function_">pvPortMalloc</span><span class="params">( <span class="type">size_t</span> xWantedSize )</span></span><br><span class="line">&#123;</span><br><span class="line">    BlockLink_t * pxBlock, * pxPreviousBlock, * pxNewBlockLink;</span><br><span class="line">    <span class="type">static</span> BaseType_t xHeapHasBeenInitialised = pdFALSE;</span><br><span class="line">    <span class="type">void</span> * pvReturn = <span class="literal">NULL</span>;</span><br><span class="line">    vTaskSuspendAll();</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* If this is the first call to malloc then the heap will require</span></span><br><span class="line"><span class="comment">         * initialisation to setup the list of free blocks. */</span></span><br><span class="line">        <span class="keyword">if</span>( xHeapHasBeenInitialised == pdFALSE )</span><br><span class="line">        &#123;</span><br><span class="line">            prvHeapInit();</span><br><span class="line">            xHeapHasBeenInitialised = pdTRUE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* The wanted size is increased so it can contain a BlockLink_t</span></span><br><span class="line"><span class="comment">         * structure in addition to the requested amount of bytes. */</span></span><br><span class="line">        <span class="keyword">if</span>( xWantedSize &gt; <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            xWantedSize += heapSTRUCT_SIZE;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Ensure that blocks are always aligned to the required number of bytes. */</span></span><br><span class="line">            <span class="keyword">if</span>( ( xWantedSize &amp; portBYTE_ALIGNMENT_MASK ) != <span class="number">0</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* Byte alignment required. */</span></span><br><span class="line">                <span class="comment">// 对齐过程存在溢出</span></span><br><span class="line">                xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize &amp; portBYTE_ALIGNMENT_MASK ) );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( ( xWantedSize &gt; <span class="number">0</span> ) &amp;&amp; ( xWantedSize &lt; configADJUSTED_HEAP_SIZE ) )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* Blocks are stored in byte order - traverse the list from the start</span></span><br><span class="line"><span class="comment">             * (smallest) block until one of adequate size is found. */</span></span><br><span class="line">            pxPreviousBlock = &amp;xStart;</span><br><span class="line">            pxBlock = xStart.pxNextFreeBlock;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 寻找一个大小合适的块，大小比xWantedSize大</span></span><br><span class="line">            <span class="keyword">while</span>( ( pxBlock-&gt;xBlockSize &lt; xWantedSize ) &amp;&amp; ( pxBlock-&gt;pxNextFreeBlock != <span class="literal">NULL</span> ) )</span><br><span class="line">            &#123;</span><br><span class="line">                pxPreviousBlock = pxBlock;</span><br><span class="line">                pxBlock = pxBlock-&gt;pxNextFreeBlock;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* If we found the end marker then a block of adequate size was not found. */</span></span><br><span class="line">            <span class="keyword">if</span>( pxBlock != &amp;xEnd )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* Return the memory space - jumping over the BlockLink_t structure</span></span><br><span class="line"><span class="comment">                 * at its start. */</span></span><br><span class="line">                <span class="comment">// 分配的内存块</span></span><br><span class="line">                pvReturn = ( <span class="type">void</span> * ) ( ( ( <span class="type">uint8_t</span> * ) pxPreviousBlock-&gt;pxNextFreeBlock ) + heapSTRUCT_SIZE );</span><br><span class="line">                <span class="comment">/* This block is being returned for use so must be taken out of the</span></span><br><span class="line"><span class="comment">                 * list of free blocks. */</span></span><br><span class="line">                pxPreviousBlock-&gt;pxNextFreeBlock = pxBlock-&gt;pxNextFreeBlock;</span><br><span class="line">                <span class="comment">/* If the block is larger than required it can be split into two. */</span></span><br><span class="line">                <span class="keyword">if</span>( ( pxBlock-&gt;xBlockSize - xWantedSize ) &gt; heapMINIMUM_BLOCK_SIZE )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">/* This block is to be split into two.  Create a new block</span></span><br><span class="line"><span class="comment">                     * following the number of bytes requested. The void cast is</span></span><br><span class="line"><span class="comment">                     * used to prevent byte alignment warnings from the compiler. */</span></span><br><span class="line">                    pxNewBlockLink = ( <span class="type">void</span> * ) ( ( ( <span class="type">uint8_t</span> * ) pxBlock ) + xWantedSize );</span><br><span class="line">                    <span class="comment">/* Calculate the sizes of two blocks split from the single</span></span><br><span class="line"><span class="comment">                     * block. */</span></span><br><span class="line">                    pxNewBlockLink-&gt;xBlockSize = pxBlock-&gt;xBlockSize - xWantedSize;</span><br><span class="line">                    pxBlock-&gt;xBlockSize = xWantedSize;</span><br><span class="line">                    <span class="comment">/* Insert the new block into the list of free blocks. */</span></span><br><span class="line">                    prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );</span><br><span class="line">                &#125;</span><br><span class="line">                xFreeBytesRemaining -= pxBlock-&gt;xBlockSize;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        traceMALLOC( pvReturn, xWantedSize );</span><br><span class="line">    &#125;</span><br><span class="line">    ( <span class="type">void</span> ) xTaskResumeAll();</span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ( configUSE_MALLOC_FAILED_HOOK == 1 )</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( pvReturn == <span class="literal">NULL</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">vApplicationMallocFailedHook</span><span class="params">( <span class="type">void</span> )</span>;</span><br><span class="line">                vApplicationMallocFailedHook();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> pvReturn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在进行xWantedSize大小对齐时，没有对对齐后的xWantedSize大小进行检查，导致可能出现整数上溢，并将未检查的xWantedSize值传递给后面的代码，直接进行内存分配，导致分配的内存大小远小于请求的大小，后续将进一步造成缓冲区溢出。</p>
<h3 id="修复方案-2"><a href="#修复方案-2" class="headerlink" title="修复方案"></a>修复方案</h3><p><a target="_blank" rel="noopener" href="https://github.com/FreeRTOS/FreeRTOS-Kernel/commit/c7a9a01c94987082b223d3e59969ede64363da63">https://github.com/FreeRTOS/FreeRTOS-Kernel/commit/c7a9a01c94987082b223d3e59969ede64363da63</a></p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">diff --git a/portable/MemMang/heap_2.c b/portable/MemMang/heap_2.c</span></span><br><span class="line"><span class="comment">index 640cd54fdd..e132ae3ea8 100644</span></span><br><span class="line"><span class="comment">--- a/portable/MemMang/heap_2.c</span></span><br><span class="line"><span class="comment">+++ b/portable/MemMang/heap_2.c</span></span><br><span class="line"><span class="meta">@@ -132,21 +131,32 @@</span> void * pvPortMalloc( size_t xWantedSize )</span><br><span class="line">             xHeapHasBeenInitialised = pdTRUE;</span><br><span class="line">         &#125;</span><br><span class="line"> </span><br><span class="line"><span class="deletion">-        /* The wanted size is increased so it can contain a BlockLink_t</span></span><br><span class="line"><span class="addition">+        /* The wanted size must be increased so it can contain a BlockLink_t</span></span><br><span class="line">          * structure in addition to the requested amount of bytes. */</span><br><span class="line"><span class="deletion">-        if( xWantedSize &gt; 0 )</span></span><br><span class="line"><span class="addition">+        if( ( xWantedSize &gt; 0 ) &amp;&amp; </span></span><br><span class="line"><span class="addition">+            ( ( xWantedSize + heapSTRUCT_SIZE ) &gt;  xWantedSize ) ) /* Overflow check */</span></span><br><span class="line">         &#123;</span><br><span class="line">             xWantedSize += heapSTRUCT_SIZE;</span><br><span class="line"> </span><br><span class="line"><span class="deletion">-            /* Ensure that blocks are always aligned to the required number of bytes. */</span></span><br><span class="line"><span class="deletion">-            if( ( xWantedSize &amp; portBYTE_ALIGNMENT_MASK ) != 0 )</span></span><br><span class="line"><span class="addition">+            /* Byte alignment required. Check for overflow. */</span></span><br><span class="line"><span class="addition">+            if( ( xWantedSize + ( portBYTE_ALIGNMENT - ( xWantedSize &amp; portBYTE_ALIGNMENT_MASK ) ) ) </span></span><br><span class="line"><span class="addition">+                    &gt; xWantedSize )</span></span><br><span class="line">             &#123;</span><br><span class="line"><span class="deletion">-                /* Byte alignment required. */</span></span><br><span class="line">                 xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize &amp; portBYTE_ALIGNMENT_MASK ) );</span><br><span class="line"><span class="addition">+                configASSERT( ( xWantedSize &amp; portBYTE_ALIGNMENT_MASK ) == 0 );</span></span><br><span class="line">             &#125;</span><br><span class="line"><span class="addition">+            else</span></span><br><span class="line"><span class="addition">+            &#123;</span></span><br><span class="line"><span class="addition">+                xWantedSize = 0;</span></span><br><span class="line"><span class="addition">+            &#125;       </span></span><br><span class="line"><span class="addition">+        &#125;</span></span><br><span class="line"><span class="addition">+        else </span></span><br><span class="line"><span class="addition">+        &#123;</span></span><br><span class="line"><span class="addition">+            xWantedSize = 0; </span></span><br><span class="line">         &#125;</span><br><span class="line"> </span><br><span class="line"><span class="deletion">-        if( ( xWantedSize &gt; 0 ) &amp;&amp; ( xWantedSize &lt; configADJUSTED_HEAP_SIZE ) )</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+        if( ( xWantedSize &gt; 0 ) &amp;&amp; ( xWantedSize &lt;= xFreeBytesRemaining ) )</span></span><br><span class="line">         &#123;</span><br><span class="line">             /* Blocks are stored in byte order - traverse the list from the start</span><br><span class="line">              * (smallest) block until one of adequate size is found. */</span><br></pre></td></tr></table></figure>

<p>修复方案是检查xWantedSize对齐之后的值，如果其比对齐之前的xWantedSize小，那说明出现溢出；如果没有溢出，那么对齐之后的xWantedSize值应该大于对齐之前的值。</p>
<h2 id="队列创建过程中内存分配存在整数溢出"><a href="#队列创建过程中内存分配存在整数溢出" class="headerlink" title="队列创建过程中内存分配存在整数溢出"></a>队列创建过程中内存分配存在整数溢出</h2><h3 id="漏洞描述-3"><a href="#漏洞描述-3" class="headerlink" title="漏洞描述"></a>漏洞描述</h3><p><strong>12&#x2F;15&#x2F;2020 - FreeRTOS Kernel V10.4.2 and earlier</strong></p>
<ul>
<li>In <a target="_blank" rel="noopener" href="https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/0b0a2060c0f40a561f97ad7bfbf35d983c33a686/queue.c#L409">queue.c</a> there is an unchecked possible addition overflow during queue allocation. This will only affect code where the size of the queue is within sizeof(queue_t) bytes of 4GB.</li>
</ul>
<p>FreeRTOS V10.4.3 and newer contains additional code that checks for and prevents these potential overflows.</p>
<p>The public CVE record for this can be found at MITRE: <a target="_blank" rel="noopener" href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-31571">CVE-2021-31571</a></p>
<p>在queue.c中，队列内存分配期间可能存在未经检查的加法溢出（整数溢出）。</p>
<h3 id="漏洞详情-3"><a href="#漏洞详情-3" class="headerlink" title="漏洞详情"></a>漏洞详情</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )</span></span><br><span class="line">    QueueHandle_t <span class="title function_">xQueueGenericCreate</span><span class="params">( <span class="type">const</span> UBaseType_t uxQueueLength,</span></span><br><span class="line"><span class="params">                                       <span class="type">const</span> UBaseType_t uxItemSize,</span></span><br><span class="line"><span class="params">                                       <span class="type">const</span> <span class="type">uint8_t</span> ucQueueType )</span></span><br><span class="line">    &#123;</span><br><span class="line">        Queue_t * pxNewQueue;</span><br><span class="line">        <span class="type">size_t</span> xQueueSizeInBytes;</span><br><span class="line">        <span class="type">uint8_t</span> * pucQueueStorage;</span><br><span class="line">        configASSERT( uxQueueLength &gt; ( UBaseType_t ) <span class="number">0</span> );</span><br><span class="line">        <span class="comment">/* Allocate enough space to hold the maximum number of items that</span></span><br><span class="line"><span class="comment">         * can be in the queue at any time.  It is valid for uxItemSize to be</span></span><br><span class="line"><span class="comment">         * zero in the case the queue is used as a semaphore. */</span></span><br><span class="line">        xQueueSizeInBytes = ( <span class="type">size_t</span> ) ( uxQueueLength * uxItemSize ); <span class="comment">/*lint !e961 MISRA exception as the casts are only redundant for some ports. */</span></span><br><span class="line">        <span class="comment">/* Check for multiplication overflow. */</span></span><br><span class="line">        configASSERT( ( uxItemSize == <span class="number">0</span> ) || ( uxQueueLength == ( xQueueSizeInBytes / uxItemSize ) ) );</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Allocate the queue and storage area.  Justification for MISRA</span></span><br><span class="line"><span class="comment">         * deviation as follows:  pvPortMalloc() always ensures returned memory</span></span><br><span class="line"><span class="comment">         * blocks are aligned per the requirements of the MCU stack.  In this case</span></span><br><span class="line"><span class="comment">         * pvPortMalloc() must return a pointer that is guaranteed to meet the</span></span><br><span class="line"><span class="comment">         * alignment requirements of the Queue_t structure - which in this case</span></span><br><span class="line"><span class="comment">         * is an int8_t *.  Therefore, whenever the stack alignment requirements</span></span><br><span class="line"><span class="comment">         * are greater than or equal to the pointer to char requirements the cast</span></span><br><span class="line"><span class="comment">         * is safe.  In other cases alignment requirements are not strict (one or</span></span><br><span class="line"><span class="comment">         * two bytes). */</span></span><br><span class="line">        <span class="comment">// 在调用pvPortMalloc()分配内存之前，没有检查sizeof( Queue_t ) + xQueueSizeInBytes是否存在溢出</span></span><br><span class="line">        pxNewQueue = ( Queue_t * ) pvPortMalloc( <span class="keyword">sizeof</span>( Queue_t ) + xQueueSizeInBytes ); <span class="comment">/*lint !e9087 !e9079 see comment above. */</span></span><br><span class="line">        <span class="keyword">if</span>( pxNewQueue != <span class="literal">NULL</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* Jump past the queue structure to find the location of the queue</span></span><br><span class="line"><span class="comment">             * storage area. */</span></span><br><span class="line">            pucQueueStorage = ( <span class="type">uint8_t</span> * ) pxNewQueue;</span><br><span class="line">            pucQueueStorage += <span class="keyword">sizeof</span>( Queue_t ); <span class="comment">/*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */</span></span><br><span class="line">            <span class="meta">#<span class="keyword">if</span> ( configSUPPORT_STATIC_ALLOCATION == 1 )</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">/* Queues can be created either statically or dynamically, so</span></span><br><span class="line"><span class="comment">                     * note this task was created dynamically in case it is later</span></span><br><span class="line"><span class="comment">                     * deleted. */</span></span><br><span class="line">                    pxNewQueue-&gt;ucStaticallyAllocated = pdFALSE;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="meta">#<span class="keyword">endif</span> <span class="comment">/* configSUPPORT_STATIC_ALLOCATION */</span></span></span><br><span class="line">            prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            traceQUEUE_CREATE_FAILED( ucQueueType );</span><br><span class="line">            mtCOVERAGE_TEST_MARKER();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pxNewQueue;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在调用pvPortMalloc()函数分配内存之前，没有检查参数sizeof( Queue_t ) + xQueueSizeInBytes是否会溢出，如果溢出，将导致分配的内存远小于所需的内存大小。xQueueSizeInBytes表示队列所需存储空间的大小（以字节为单位），它决定了队列中可以存储多少数据；sizeof( Queue_t ) + xQueueSizeInBytes表示队列对象Queue_t的总大小是Queue_t结构体的大小加上队列数据存储区的大小。</p>
<h3 id="修复方案-3"><a href="#修复方案-3" class="headerlink" title="修复方案"></a>修复方案</h3><p><a target="_blank" rel="noopener" href="https://github.com/FreeRTOS/FreeRTOS-Kernel/commit/47338393f1f79558f6144213409f09f81d7c4837">https://github.com/FreeRTOS/FreeRTOS-Kernel/commit/47338393f1f79558f6144213409f09f81d7c4837</a></p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">diff --git a/queue.c b/queue.c</span></span><br><span class="line"><span class="comment">index d2e27e55a5..b01dfd11ff 100644</span></span><br><span class="line"><span class="comment">--- a/queue.c</span></span><br><span class="line"><span class="comment">+++ b/queue.c</span></span><br><span class="line"><span class="meta">@@ -397,6 +397,9 @@</span> BaseType_t xQueueGenericReset( QueueHandle_t xQueue,</span><br><span class="line">         /* Check for multiplication overflow. */</span><br><span class="line">         configASSERT( ( uxItemSize == 0 ) || ( uxQueueLength == ( xQueueSizeInBytes / uxItemSize ) ) );</span><br><span class="line"> </span><br><span class="line"><span class="addition">+        /* Check for addition overflow. */</span></span><br><span class="line"><span class="addition">+        configASSERT( ( sizeof( Queue_t ) + xQueueSizeInBytes ) &gt;  xQueueSizeInBytes );</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line">         /* Allocate the queue and storage area.  Justification for MISRA</span><br><span class="line">          * deviation as follows:  pvPortMalloc() always ensures returned memory</span><br><span class="line">          * blocks are aligned per the requirements of the MCU stack.  In this case</span><br></pre></td></tr></table></figure>

<p>修复方法是添加一个断言，如果sizeof( Queue_t ) + xQueueSizeInBytes的大小大于xQueueSizeInBytes，则没有产生溢出，否则，出现溢出，断言configASSERT就会报错，触发错误处理。</p>
<h2 id="流缓冲区创建过程中内存分配存在整数溢出"><a href="#流缓冲区创建过程中内存分配存在整数溢出" class="headerlink" title="流缓冲区创建过程中内存分配存在整数溢出"></a>流缓冲区创建过程中内存分配存在整数溢出</h2><h3 id="漏洞描述-4"><a href="#漏洞描述-4" class="headerlink" title="漏洞描述"></a>漏洞描述</h3><p><strong>12&#x2F;15&#x2F;2020 - FreeRTOS Kernel V10.4.2 and earlier</strong></p>
<ul>
<li>In <a target="_blank" rel="noopener" href="https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/0b0a2060c0f40a561f97ad7bfbf35d983c33a686/stream_buffer.c#L262">stream_buffer.c</a> there is an unchecked possible addition overflow during steam buffer creation. This will only affect code where the size of the stream buffer is within sizeof(StreamBuffer_t) bytes of 4GB.</li>
</ul>
<p>FreeRTOS V10.4.3 and newer contains additional code that checks for and prevents these potential overflows.</p>
<p>The public CVE record for this can be found at MITRE: <a target="_blank" rel="noopener" href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-31572">CVE-2021-31572</a></p>
<p>在stream_buffer.c中，创建流缓冲区期间可能存在未经检查的加法溢出（整数溢出）。</p>
<h3 id="漏洞详情-4"><a href="#漏洞详情-4" class="headerlink" title="漏洞详情"></a>漏洞详情</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )</span></span><br><span class="line">    StreamBufferHandle_t <span class="title function_">xStreamBufferGenericCreate</span><span class="params">( <span class="type">size_t</span> xBufferSizeBytes,</span></span><br><span class="line"><span class="params">                                                     <span class="type">size_t</span> xTriggerLevelBytes,</span></span><br><span class="line"><span class="params">                                                     BaseType_t xIsMessageBuffer )</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">uint8_t</span> * pucAllocatedMemory;</span><br><span class="line">        <span class="type">uint8_t</span> ucFlags;</span><br><span class="line">        <span class="comment">/* In case the stream buffer is going to be used as a message buffer</span></span><br><span class="line"><span class="comment">         * (that is, it will hold discrete messages with a little meta data that</span></span><br><span class="line"><span class="comment">         * says how big the next message is) check the buffer will be large enough</span></span><br><span class="line"><span class="comment">         * to hold at least one message. */</span></span><br><span class="line">        <span class="keyword">if</span>( xIsMessageBuffer == pdTRUE )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* Is a message buffer but not statically allocated. */</span></span><br><span class="line">            ucFlags = sbFLAGS_IS_MESSAGE_BUFFER;</span><br><span class="line">            configASSERT( xBufferSizeBytes &gt; sbBYTES_TO_STORE_MESSAGE_LENGTH );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* Not a message buffer and not statically allocated. */</span></span><br><span class="line">            ucFlags = <span class="number">0</span>;</span><br><span class="line">            configASSERT( xBufferSizeBytes &gt; <span class="number">0</span> );</span><br><span class="line">        &#125;</span><br><span class="line">        configASSERT( xTriggerLevelBytes &lt;= xBufferSizeBytes );</span><br><span class="line">        <span class="comment">/* A trigger level of 0 would cause a waiting task to unblock even when</span></span><br><span class="line"><span class="comment">         * the buffer was empty. */</span></span><br><span class="line">        <span class="keyword">if</span>( xTriggerLevelBytes == ( <span class="type">size_t</span> ) <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            xTriggerLevelBytes = ( <span class="type">size_t</span> ) <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* A stream buffer requires a StreamBuffer_t structure and a buffer.</span></span><br><span class="line"><span class="comment">         * Both are allocated in a single call to pvPortMalloc().  The</span></span><br><span class="line"><span class="comment">         * StreamBuffer_t structure is placed at the start of the allocated memory</span></span><br><span class="line"><span class="comment">         * and the buffer follows immediately after.  The requested size is</span></span><br><span class="line"><span class="comment">         * incremented so the free space is returned as the user would expect -</span></span><br><span class="line"><span class="comment">         * this is a quirk of the implementation that means otherwise the free</span></span><br><span class="line"><span class="comment">         * space would be reported as one byte smaller than would be logically</span></span><br><span class="line"><span class="comment">         * expected. */</span></span><br><span class="line">        xBufferSizeBytes++;</span><br><span class="line">        <span class="comment">// 在调用pvPortMalloc()分配内存之前，没有检查xBufferSizeBytes + sizeof( StreamBuffer_t )是否存在溢出</span></span><br><span class="line">        pucAllocatedMemory = ( <span class="type">uint8_t</span> * ) pvPortMalloc( xBufferSizeBytes + <span class="keyword">sizeof</span>( StreamBuffer_t ) ); <span class="comment">/*lint !e9079 malloc() only returns void*. */</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>( pucAllocatedMemory != <span class="literal">NULL</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            prvInitialiseNewStreamBuffer( ( StreamBuffer_t * ) pucAllocatedMemory,       <span class="comment">/* Structure at the start of the allocated memory. */</span> <span class="comment">/*lint !e9087 Safe cast as allocated memory is aligned. */</span> <span class="comment">/*lint !e826 Area is not too small and alignment is guaranteed provided malloc() behaves as expected and returns aligned buffer. */</span></span><br><span class="line">                                          pucAllocatedMemory + <span class="keyword">sizeof</span>( StreamBuffer_t ), <span class="comment">/* Storage area follows. */</span> <span class="comment">/*lint !e9016 Indexing past structure valid for uint8_t pointer, also storage area has no alignment requirement. */</span></span><br><span class="line">                                          xBufferSizeBytes,</span><br><span class="line">                                          xTriggerLevelBytes,</span><br><span class="line">                                          ucFlags );</span><br><span class="line">            traceSTREAM_BUFFER_CREATE( ( ( StreamBuffer_t * ) pucAllocatedMemory ), xIsMessageBuffer );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            traceSTREAM_BUFFER_CREATE_FAILED( xIsMessageBuffer );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ( StreamBufferHandle_t ) pucAllocatedMemory; <span class="comment">/*lint !e9087 !e826 Safe cast as allocated memory is aligned. */</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在调用pvPortMalloc()函数分配内存之前，没有检查参数xBufferSizeBytes + sizeof( StreamBuffer_t )是否会溢出，如果溢出，将导致分配的内存远小于所需的内存大小。</p>
<h3 id="修复方案-4"><a href="#修复方案-4" class="headerlink" title="修复方案"></a>修复方案</h3><p><a target="_blank" rel="noopener" href="https://github.com/FreeRTOS/FreeRTOS-Kernel/commit/d05b9c123f2bf9090bce386a244fc934ae44db5b">https://github.com/FreeRTOS/FreeRTOS-Kernel/commit/d05b9c123f2bf9090bce386a244fc934ae44db5b</a></p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">diff --git a/stream_buffer.c b/stream_buffer.c</span></span><br><span class="line"><span class="comment">index 03cfc06156..fec03a7816 100644</span></span><br><span class="line"><span class="comment">--- a/stream_buffer.c</span></span><br><span class="line"><span class="comment">+++ b/stream_buffer.c</span></span><br><span class="line"><span class="meta">@@ -258,8 +258,16 @@</span> static void prvInitialiseNewStreamBuffer( StreamBuffer_t * const pxStreamBuffer,</span><br><span class="line">          * this is a quirk of the implementation that means otherwise the free</span><br><span class="line">          * space would be reported as one byte smaller than would be logically</span><br><span class="line">          * expected. */</span><br><span class="line"><span class="deletion">-        xBufferSizeBytes++;</span></span><br><span class="line"><span class="deletion">-        pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); /*lint !e9079 malloc() only returns void*. */</span></span><br><span class="line"><span class="addition">+        if( xBufferSizeBytes &lt; ( xBufferSizeBytes + 1 + sizeof( StreamBuffer_t ) ) )</span></span><br><span class="line"><span class="addition">+        &#123;</span></span><br><span class="line"><span class="addition">+            xBufferSizeBytes++;</span></span><br><span class="line"><span class="addition">+            pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); /*lint !e9079 malloc() only returns void*. */</span></span><br><span class="line"><span class="addition">+        &#125;</span></span><br><span class="line"><span class="addition">+        else</span></span><br><span class="line"><span class="addition">+        &#123;</span></span><br><span class="line"><span class="addition">+            pucAllocatedMemory = NULL;</span></span><br><span class="line"><span class="addition">+        &#125;</span></span><br><span class="line"><span class="addition">+        </span></span><br><span class="line"> </span><br><span class="line">         if( pucAllocatedMemory != NULL )</span><br><span class="line">         &#123;</span><br></pre></td></tr></table></figure>

<p>修复方法是检查xBufferSizeBytes的值是否比xBufferSizeBytes + 1 + sizeof( StreamBuffer_t )的值要小，如果比相加之后的值小，说明没有溢出，否则产生溢出。</p>
<p><strong>参考资料：</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.freertos.org/zh-cn-cmn-s/FreeRTOS-Plus/FreeRTOS_Plus_TCP/Embedded_Ethernet_Buffer_Management.html">TCP&#x2F;IP 堆栈网络缓冲区分配方案</a></p>
<p><a target="_blank" rel="noopener" href="https://www.freertos.org/security/security_updates.html">FreeRTOS Security Updates</a></p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">Home</a></li>
        
          <li><a href="/archives/">Archives</a></li>
        
          <li><a href="/categories/">Categories</a></li>
        
          <li><a href="/tags/">Tags</a></li>
        
          <li><a href="/about/">About</a></li>
        
          <li><a href="/note/">Note</a></li>
        
          <li><a href="/link/">Links</a></li>
        
          <li><a href="/search/">Search</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-IP-%E5%A0%86%E6%A0%88%E7%BD%91%E7%BB%9C%E7%BC%93%E5%86%B2%E5%8C%BA%E5%88%86%E9%85%8D%E5%AD%98%E5%9C%A8%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA"><span class="toc-number">1.</span> <span class="toc-text">TCP&#x2F;IP 堆栈网络缓冲区分配存在整数溢出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E6%8F%8F%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">漏洞描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E8%AF%A6%E6%83%85"><span class="toc-number">1.2.</span> <span class="toc-text">漏洞详情</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88"><span class="toc-number">1.3.</span> <span class="toc-text">修复方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ARMv7-M-%E5%92%8C-ARMv8-M-MPU-%E7%9A%84%E7%A7%BB%E6%A4%8D%E7%89%88%E6%9C%AC%E5%AD%98%E5%9C%A8%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87"><span class="toc-number">2.</span> <span class="toc-text">ARMv7-M 和 ARMv8-M MPU 的移植版本存在权限提升</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E6%8F%8F%E8%BF%B0-1"><span class="toc-number">2.1.</span> <span class="toc-text">漏洞描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E8%AF%A6%E6%83%85-1"><span class="toc-number">2.2.</span> <span class="toc-text">漏洞详情</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88-1"><span class="toc-number">2.3.</span> <span class="toc-text">修复方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E4%B8%AD%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%AD%98%E5%9C%A8%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA"><span class="toc-number">3.</span> <span class="toc-text">堆中动态内存分配存在整数溢出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E6%8F%8F%E8%BF%B0-2"><span class="toc-number">3.1.</span> <span class="toc-text">漏洞描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E8%AF%A6%E6%83%85-2"><span class="toc-number">3.2.</span> <span class="toc-text">漏洞详情</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88-2"><span class="toc-number">3.3.</span> <span class="toc-text">修复方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%AD%98%E5%9C%A8%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA"><span class="toc-number">4.</span> <span class="toc-text">队列创建过程中内存分配存在整数溢出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E6%8F%8F%E8%BF%B0-3"><span class="toc-number">4.1.</span> <span class="toc-text">漏洞描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E8%AF%A6%E6%83%85-3"><span class="toc-number">4.2.</span> <span class="toc-text">漏洞详情</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88-3"><span class="toc-number">4.3.</span> <span class="toc-text">修复方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E7%BC%93%E5%86%B2%E5%8C%BA%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%AD%98%E5%9C%A8%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA"><span class="toc-number">5.</span> <span class="toc-text">流缓冲区创建过程中内存分配存在整数溢出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E6%8F%8F%E8%BF%B0-4"><span class="toc-number">5.1.</span> <span class="toc-text">漏洞描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E8%AF%A6%E6%83%85-4"><span class="toc-number">5.2.</span> <span class="toc-text">漏洞详情</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88-4"><span class="toc-number">5.3.</span> <span class="toc-text">修复方案</span></a></li></ol></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://sx1ang.github.io/2024/02/19/FreeRTOS%E6%BC%8F%E6%B4%9E%E6%95%B4%E7%90%86/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://sx1ang.github.io/2024/02/19/FreeRTOS%E6%BC%8F%E6%B4%9E%E6%95%B4%E7%90%86/&text=FreeRTOS漏洞整理"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://sx1ang.github.io/2024/02/19/FreeRTOS%E6%BC%8F%E6%B4%9E%E6%95%B4%E7%90%86/&title=FreeRTOS漏洞整理"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://sx1ang.github.io/2024/02/19/FreeRTOS%E6%BC%8F%E6%B4%9E%E6%95%B4%E7%90%86/&is_video=false&description=FreeRTOS漏洞整理"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=FreeRTOS漏洞整理&body=Check out this article: https://sx1ang.github.io/2024/02/19/FreeRTOS%E6%BC%8F%E6%B4%9E%E6%95%B4%E7%90%86/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://sx1ang.github.io/2024/02/19/FreeRTOS%E6%BC%8F%E6%B4%9E%E6%95%B4%E7%90%86/&title=FreeRTOS漏洞整理"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://sx1ang.github.io/2024/02/19/FreeRTOS%E6%BC%8F%E6%B4%9E%E6%95%B4%E7%90%86/&title=FreeRTOS漏洞整理"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://sx1ang.github.io/2024/02/19/FreeRTOS%E6%BC%8F%E6%B4%9E%E6%95%B4%E7%90%86/&title=FreeRTOS漏洞整理"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://sx1ang.github.io/2024/02/19/FreeRTOS%E6%BC%8F%E6%B4%9E%E6%95%B4%E7%90%86/&title=FreeRTOS漏洞整理"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://sx1ang.github.io/2024/02/19/FreeRTOS%E6%BC%8F%E6%B4%9E%E6%95%B4%E7%90%86/&name=FreeRTOS漏洞整理&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://sx1ang.github.io/2024/02/19/FreeRTOS%E6%BC%8F%E6%B4%9E%E6%95%B4%E7%90%86/&t=FreeRTOS漏洞整理"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
	Copyright &copy;
	
	
	2023-2024
	叶送溪
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
